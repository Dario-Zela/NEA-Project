using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using Models.WorldGen;

/// <summary>
/// The world creation algorithm, taking inspiration from the Unity's implementations;
/// Ken Perlins algorithm, enhanced by the implementation by https://flafla2.github.io/2014/08/09/perlinnoise.html;
/// and Urbis Terram https://digitalcommons.wpi.edu/cgi/viewcontent.cgi?article=1397&context=etd-theses;
/// </summary>
namespace Models.WorldGen
{

    #region PerlinNoise
    /// <summary>
    /// An implementation of the improved perlin noise generator;
    /// Created by Ken Perlin in his second paper;
    /// Slightly modified by me to implement a seed mechanic;
    /// </summary>
    public class PerlinNoise
    {
        /// <summary>
        /// The Permutations array used in the function;
        /// Created by Ken Perlin it contains all of the values form 0 to 255;
        /// It is used as a hash lookup table when generating the noise
        /// </summary>
        private int[] permutations = {151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};

        /// <summary>
        /// Actual permutation table; which is simply the one above repeated twice;
        /// </summary>
        private int[] p;

        /// <summary>
        /// The actual seed;
        /// A float multiplyer for the weight on the lerp function;
        /// </summary>
        private float seed = new float();

        int octaves;
        float persistence, lacunarity;

        /// <summary>
        /// Class constructor;
        /// Assigns the seed value of the world;
        /// </summary>
        public PerlinNoise(int octaves, float persistence, float lacunarity, float seed = 1)
        {
            this.seed = (seed * 36) / 128.0f;
            p = new int[512];
            permutations.CopyTo(p, 0);
            permutations.CopyTo(p, 256);
            this.octaves = octaves;
            this.persistence = persistence;
            this.lacunarity = lacunarity;
        }

        /// <summary>
        /// It create an ease curve that smooths out the results produced by the algorithm;
        /// It is needed as the function works on linear interpolation, which, while computationally simple;
        /// Produces unnatural looking curves;
        /// The function uses the formula 6t^5-15t^4+10t^3, also generated by Ken Perlin in his papers;
        /// </summary>
        /// <param name="t">The variable that it is used upon;
        /// In this case it is the float component of the x and y values</param>
        /// <returns>It returns the smoothed out value</returns>
        private float fade(float t)
        {
            float val = t * t * t * (t * (t * 6 - 15) + 10);
            return val;
        }

        /// <summary>
        /// It takes the pseudorandom value given by the algorithm;
        /// Which is just one of the values in the Hash Table;
        /// And gives the gradient(Math Operation) of the hash vector;
        /// Which is composed of the digits of the number;
        /// And the given vector;
        /// which is the combination of the x y and z values;
        /// </summary>
        /// <param name="Hash">The given hash value</param>
        /// <param name="x">The given x component</param>
        /// <param name="y">The given y component</param>
        /// <param name="z">The given z component</param>
        /// <returns>The gradient of the two vectors</returns>
        private float Grad(int Hash, float x, float y, float z)
        {
            switch (Hash & 0xF)                 //In this the value 0xF is the value 15
            {
                case 0x0: return x + y;
                case 0x1: return -x + y;
                case 0x2: return x - y;
                case 0x3: return -x - y;
                case 0x4: return x + z;
                case 0x5: return -x + z;
                case 0x6: return x - z;
                case 0x7: return -x - z;
                case 0x8: return y + z;
                case 0x9: return -y + z;
                case 0xA: return y - z;
                case 0xB: return -y - z;
                case 0xC: return y + x;
                case 0xD: return -y + z;
                case 0xE: return y - x;
                case 0xF: return -y - z;
                default: return 0; // never happens
            }
        }

        /// <summary>
        /// It gives the weighted sum of the values;
        /// </summary>
        /// <param name="t">The weight component, given the fade over a value</param>
        /// <param name="a">The first value</param>
        /// <param name="b">The second value</param>
        /// <returns>The weighted sum</returns>
        private float Lerp(float t, float a, float b)
        {
            return a + t * (b - a);
        }

        /// <summary>
        /// This generates the perlin noise for two values
        /// </summary>
        /// <param name="x">The first component</param>
        /// <param name="y">The second component</param>
        /// <returns>A number between 0 and 1</returns>
        public float PerlinNoiseGen(float x, float y)
        {
            var X = (int)x & 0xff;      // x & 0xff is the same as x % 256
            var Y = (int)y & 0xff;
            var Z = (int)seed & 0xff;    // I use the z vaue as the seed

            x -= (int)x;
            y -= (int)y;
            var z = seed - (int)seed;

            var u = fade(x);        //These are the normalised weights
            var v = fade(y);
            var w = fade(z);

            int aaa, aba, aab, abb, baa, bba, bab, bbb;             //This is the hash algorithm implemented by Ken Perlin
            aaa = p[p[p[X] + Y] + Z];
            aba = p[p[p[X] + inc(Y)] + Z];
            aab = p[p[p[X] + Y] + inc(Z)];
            abb = p[p[p[X] + inc(Y)] + inc(Z)];
            baa = p[p[p[inc(X)] + Y] + Z];
            bba = p[p[p[inc(X)] + inc(Y)] + Z];
            bab = p[p[p[inc(X)] + Y] + inc(Z)];
            bbb = p[p[p[inc(X)] + inc(Y)] + inc(Z)];

            //The following functions create the smooth terrain.
            //They take hash values generated before and apply the gradient over the x and y components, taking into
            //consideration other positions.
            //A weighted sum over all the possible gratients is taken to create the value
            //This is how the value is formed
            float x1, x2, y1, y2;

            x1 = Lerp(u, Grad(aaa, x, y, z), Grad(baa, x - 1, y, z));
            x2 = Lerp(u, Grad(aba, x, y - 1, z), Grad(bba, x - 1, y - 1, z));
            y1 = Lerp(v, x1, x2);

            x1 = Lerp(u, Grad(aab, x, y, z - 1), Grad(bab, x - 1, y, z - 1));
            x2 = Lerp(u, Grad(abb, x, y - 1, z - 1), Grad(bbb, x - 1, y - 1, z - 1));
            y2 = Lerp(v, x1, x2);

            return (Lerp(w, y1, y2) + 1) / 2f;
        }

        /// <summary>
        /// Does an increament to a value and then returns it
        /// </summary>
        /// <param name="y">The value to be incremented</param>
        /// <returns>y+1</returns>
        private int inc(int y)
        {
            y++;
            return y;
        }

        /// <summary>
        /// Creates an octave noise, which is a combination of Perlin genarated noise
        /// </summary>
        /// <param name="x">The x coordinate</param>
        /// <param name="y">The y coordinate</param>
        /// <param name="octaves">How many frequencies should be combined</param>
        /// <param name="persistence">How the amplitude changes between Perlin noise executions</param>
        /// <param name="lacunarity">How the frequency should change between executions;
        /// Usually 2, it can be changed to edit how the frequency changes between octaves</param>
        /// <returns></returns>
        public float OctaveNoiseGen(float x, float y)
        {
            float total = 0;
            float frequency = 1;
            float amplitude = 1;
            float MaxValue = 0;
            for (int i = 0; i < octaves; i++)
            {
                total += (PerlinNoiseGen(x * frequency, y * frequency) * 2 - 1) * amplitude;

                MaxValue += amplitude;
                amplitude *= persistence;
                frequency *= lacunarity;
            }
            return total / MaxValue;
        }
    }
    #endregion

    #region MapGen
    /// <summary>
    /// The base world builder;
    /// It constructs the blank world;
    /// </summary>
    public class MapGen
    {
        public MapGen() { }

        
        #region Old
        public (float[,], float[,], float[,]) GenerateNoiseMap(int mapDepth, int mapWidth, int seed, int Octaves, float Persistance, float Lacunarity, int REGION_FRACTION_TO_CONSIDER)
        {
            float[,] NoiseMap = new float[mapDepth, mapWidth];
            PerlinNoise perlin = new PerlinNoise(Octaves, Persistance, Lacunarity, seed);
            float[,] maximas = new float[mapDepth, mapWidth];
            float[,] minimas = new float[mapDepth, mapWidth];
            float maxNoise = float.MinValue;
            float minNoise = float.MaxValue;
            for (int zIndex = 0; zIndex < mapDepth; zIndex++)
            {
                for (int xIndex = 0; xIndex < mapWidth; xIndex++)
                {
                    float tempMax = float.MinValue;
                    float tempMin = float.MaxValue;
                    float noise = 0;
                    int nTiles = 0;
                    for (int i = 0; i < Constants.REGION_HEIGHT / REGION_FRACTION_TO_CONSIDER; i++)
                    {
                        for (int j = 0; j < Constants.REGION_WIDTH / REGION_FRACTION_TO_CONSIDER; j++)
                        {
                            float SampleIndexX = noiseX(xIndex, i * REGION_FRACTION_TO_CONSIDER);
                            float SampleIndexZ = noiseY(zIndex, j * REGION_FRACTION_TO_CONSIDER);
                            nTiles++;
                            noise += perlin.OctaveNoiseGen(SampleIndexX, SampleIndexZ);
                            if (noise > maxNoise)
                            {
                                maxNoise = noise;
                            }
                            else if (noise < minNoise)
                            {
                                minNoise = noise;
                            }
                            if(tempMax < noise)
                            {
                                tempMax = noise;
                            }
                            else if(tempMin > noise)
                            {
                                tempMin = noise;
                            }
                        }
                    }
                    NoiseMap[xIndex, zIndex] = noise;
                    maximas[xIndex, zIndex] = tempMax;
                    minimas[xIndex, zIndex] = tempMin;
                }
            }
            for (int i = 0; i < mapDepth; i++)
            {
                for (int j = 0; j < mapWidth; j++)
                {
                    NoiseMap[j, i] = InverseLerp(minNoise, maxNoise, NoiseMap[j, i]);
                    maximas[j, i] = InverseLerp(minNoise, maxNoise, maximas[j, i]);
                    minimas[j, i] = InverseLerp(minNoise, maxNoise, minimas[j, i]);
                }
            }

            return (NoiseMap, maximas, minimas);
        }

        private float InverseLerp(float min, float max, float value)
        {
            return (value - min) / (max - min);
        }
        #endregion


        public void startMap(ref Map World)
        {
            for (int i = 0; i < Constants.WORLD_TILES_COUNT; i++)
            {
                World.landBlocks.Add(new Block());
            }
            World.migrantCounter = 0;
            World.remainingSettlers = 200;
            for (int i = 0; i < Constants.WORLD_TILES_COUNT; i++)
            {
                World.civs.regionInfo.Add(new regionInfo());
            }
        }

        public void noiseMap(ref Map World, int seed, int octaves, float persistence, float lacunarity)
        {
            const int REGION_FRACTION_TO_CONSIDER = 64;
            (float[,], float[,], float[,]) temp = GenerateNoiseMap(Constants.WORLD_HEIGHT, Constants.WORLD_WIDTH, seed, octaves, persistence, lacunarity, REGION_FRACTION_TO_CONSIDER);
            float[,] noiseMap = temp.Item1;
            float[,] maximas = temp.Item2;
            float[,] minimas = temp.Item3;
            const float maxTemperature = 56.7f;
            const float minTemperature = -55.2f;
            const float temperatureRange = maxTemperature - minTemperature;
            float halfHeight = Constants.WORLD_HEIGHT / 2.0f;

            for (int y = 0; y < Constants.WORLD_HEIGHT; y++)
            {
                int distanceFromEquator = (int)(halfHeight / 2) - y;
                float tempRangePct = 1.0f - (float)(distanceFromEquator / halfHeight);
                float baseTempByLatitulde = (tempRangePct * temperatureRange) + minTemperature;
                for (int x = 0; x < Constants.WORLD_WIDTH; x++)
                {
                    World.landBlocks[World.idx(x, y)].height = noiseToHeight(noiseMap[x,y]);
                    World.landBlocks[World.idx(x, y)].type = 0;
                    World.landBlocks[World.idx(x, y)].variance = noiseToHeight(maximas[x,y]) - noiseToHeight(minimas[x,y]);
                    float altitudeDeduction = (World.landBlocks[World.idx(x, y)].height - World.waterHeight) / 10f;
                    World.landBlocks[World.idx(x, y)].temperature = (byte)(baseTempByLatitulde - altitudeDeduction);
                    if (World.landBlocks[World.idx(x, y)].temperature < -55) World.landBlocks[World.idx(x, y)].temperature = -55;
                    if (World.landBlocks[World.idx(x, y)].temperature > 55) World.landBlocks[World.idx(x, y)].temperature = 55;
                }
            }
        }

        const float NOISE_SIZE = 384.0f;

        private float noiseX(int worldX, int regionX)
        {
            float bigX = (worldX * Constants.WORLD_WIDTH) + regionX;
            return bigX / (Constants.WORLD_WIDTH * Constants.REGION_WIDTH) * NOISE_SIZE;
        }

        private float noiseY(int worldY, int regionY)
        {
            float bigY = (worldY * Constants.WORLD_HEIGHT) + regionY;
            return bigY / (Constants.WORLD_HEIGHT * Constants.REGION_HEIGHT) * NOISE_SIZE;
        }

        private int noiseToHeight(float noiseHeight)
        {
            return (int)((noiseHeight + 1) * 150f);
        }

        private int determineProportions(ref Map World, ref int candidate, int target)
        {
            int count = 0;
            while (count < target)
            {
                int copy = candidate;
                count = World.landBlocks.FindAll(block => block.height <= copy).Count;
                if (count >= target)
                {
                    return candidate;
                }
                else
                {
                    candidate++;
                }
            }
            throw new Exception();
        }

        public void baseTypeAllocation(ref Map World)
        {
            int candidate = 0;
            int remainingDivisor = 10 - (World.waterDivisor + World.plainsDivisor);
            int nCellWater = (Constants.WORLD_TILES_COUNT / World.waterDivisor);
            int nCellPlains = (Constants.WORLD_TILES_COUNT / World.plainsDivisor) + nCellWater;
            int nCellHills = (Constants.WORLD_TILES_COUNT / remainingDivisor) + nCellPlains;

            World.waterHeight = determineProportions(ref World, ref candidate, nCellWater);
            World.plainsHeight = determineProportions(ref World, ref candidate, nCellPlains);
            World.hillsHeight = determineProportions(ref World, ref candidate, nCellHills);

            for (int i = 0; i < World.landBlocks.Count; i++)
            {
                if (World.landBlocks[i].height <= World.waterHeight)
                {
                    World.landBlocks[i].type = (int)blockType.WATER;
                    World.landBlocks[i].rainfall = 10;
                    if (World.landBlocks[i].height + World.landBlocks[i].variance / 2 > World.waterHeight)
                        World.landBlocks[i].type = (int)blockType.SALT_MARSH;
                }
                else if (World.landBlocks[i].height <= World.plainsHeight)
                {
                    World.landBlocks[i].type = (int)blockType.PLAINS;
                    World.landBlocks[i].rainfall = 10;
                    if (World.landBlocks[i].height - World.landBlocks[i].variance / 2 > World.waterHeight)
                        World.landBlocks[i].type = (int)blockType.MARSH;
                }
                else if (World.landBlocks[i].height <= World.hillsHeight)
                {
                    World.landBlocks[i].type = (int)blockType.HILLS;
                    World.landBlocks[i].rainfall = 20;
                    if (World.landBlocks[i].variance < 2)
                    {
                        World.landBlocks[i].type = (int)blockType.HIGHLANDS;
                        World.landBlocks[i].rainfall = 10;
                    }
                }
                else
                {
                    World.landBlocks[i].type = (int)blockType.MOUNTAINS;
                    World.landBlocks[i].rainfall = 30;
                    if (World.landBlocks[i].variance < 3)
                    {
                        World.landBlocks[i].type = (int)blockType.PLATEAU;
                        World.landBlocks[i].rainfall = 10;
                    }
                }
            }
        }

        public void markCoastlines(ref Map World)
        {
            for (int y = 1; y < Constants.WORLD_HEIGHT - 1; y++)
            {
                for (int x = 1; x < Constants.WORLD_WIDTH - 1; x++)
                {
                    if (World.landBlocks[World.idx(x, y)].type > (int)blockType.WATER)
                    {
                        if (
                            World.landBlocks[World.idx(x - 1, y - 1)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x, y - 1)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x + 1, y - 1)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x - 1, y)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x + 1, y)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x - 1, y + 1)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x, y + 1)].type == (int)blockType.WATER ||
                            World.landBlocks[World.idx(x + 1, y + 1)].type == (int)blockType.WATER
                        )
                        {
                            World.landBlocks[World.idx(x, y)].type = (int)blockType.COASTAL;
                            World.landBlocks[World.idx(x, y)].rainfall = 20;
                        }
                    }
                }
            }
        }

        public void createRainfall(ref Map World)
        {
            for (int y = 0; y < Constants.WORLD_HEIGHT; ++y)
            {
                int rainAmount = 10;
                for (int x = 0; x < Constants.WORLD_WIDTH; ++x)
                {
                    if (World.landBlocks[World.idx(x, y)].type == (int)blockType.MOUNTAINS)
                    {
                        rainAmount -= 20;
                    }
                    else if (World.landBlocks[World.idx(x, y)].type == (int)blockType.HILLS)
                    {
                        rainAmount -= 10;
                    }
                    else if (World.landBlocks[World.idx(x, y)].type == (int)blockType.COASTAL)
                    {
                        rainAmount -= 5;
                    }
                    else
                    {
                        rainAmount += 1;
                    }
                    if (rainAmount < 0) rainAmount = 0;
                    if (rainAmount > 20) rainAmount = 20;

                    World.landBlocks[World.idx(x, y)].rainfall += rainAmount;
                    if (World.landBlocks[World.idx(x, y)].rainfall < 0) World.landBlocks[World.idx(x, y)].rainfall = 0;
                    if (World.landBlocks[World.idx(x, y)].rainfall > 100) World.landBlocks[World.idx(x, y)].rainfall = 100;
                }
            }
        }
    }
    #endregion

    #region Header

    public enum Gender
    {
        Male,
        Female,
        Unknown
    }

    public enum Sexuality
    {
        Heterosexual,
        Homosexual,
        Bisexual,
        Asexual
    }

    public enum HairStyle
    {
        Bald,
        Short,
        Long,
        Pigtails,
        Mohawk,
        Balding
    }

    public class Specie
    {
        public string tag = "";
        public int index = 0;
        public Gender gender = new Gender();
        public Sexuality sexuality = new Sexuality();
        public HairStyle hairStyle = new HairStyle();
        public (string, Colour) skinColour = ("", new Colour(0, 0, 0));
        public (string, Colour) hair_color = ("", new Colour(0, 0, 0));
        public float height = 0;
        public float weight = 0;
        public bool bearded = false;
        public int baseMaleGlyph = 0;
        public int baseFemaleGlyph = 0;

        public string proNoun
        {
            get
            {
                switch (gender)
                {
                    case Gender.Male: return "He";
                    case Gender.Female: return "She";
                    case Gender.Unknown: return "Xi";
                    default: throw new Exception();
                }
            }
        }
        public string Ethnicity
        {
            get
            {
                return skinColour.Item1;
            }
        }
    }

    public enum Diet
    {
        Omnivore,
        Herbivore,
        Carnivore
    };

    public enum Alignment
    {
        Good,
        Neutral,
        Evil,
        Devour
    };

    public class Colour
    {
        public Colour(byte R, byte G, byte B) {
            r = R;
            g = G;
            b = B;
        }

        public byte r;
        public byte g;
        public byte b;

        public static bool operator ==(Colour A, Colour B)
        {
            return A.r == B.r && A.g == B.g && A.b == B.b;
        }

        public static bool operator !=(Colour A, Colour B)
        {
            return !(A == B);
        }

        public override bool Equals(object obj)
        {
            return obj is Colour colour &&
                   r == colour.r &&
                   g == colour.g &&
                   b == colour.b;
        }

        public override int GetHashCode()
        {
            var hashCode = -839137856;
            hashCode = hashCode * -1521134295 + r.GetHashCode();
            hashCode = hashCode * -1521134295 + g.GetHashCode();
            hashCode = hashCode * -1521134295 + b.GetHashCode();
            return hashCode;
        }
    };

    public class rawSpecies
    {
        public string tag = "", name = "", maleName = "", femaleName = "", collectiveName = "", description = "";
        public Dictionary<string, int> statMods = new Dictionary<string, int>();
        public List<(string, int, int)> bodyParts = new List<(string, int, int)>();
        public Diet diet = Diet.Omnivore;
        public Alignment alignment = Alignment.Neutral;
        public bool spreadsBlight = false;
        public int maxAge = 90, infantAge = 5, childAge = 12;
        public char glyph = '@', glyphAscii = '@', worldgenGlyph = '@';
        public List<(string, Colour)> skinColors = new List<(string, Colour)>(), hairColors = new List<(string, Colour)>();
    };

    public class civUnitNaturalAttack
    {
        public string type = "";
        public int hitBonus = 0;
        public int Dice = 0;
        public int dieType = 6;
        public int dieMod = 0;
        public int range = 0;
    };

    public class civEquipment
    {
        public List<(int, string, string)> startingClothes = new List<(int, string, string)>();
        public string melee = "";
        public string ranged = "";
        public string ammo = "";
        public string mount = "";
    };

    public class civUnitSentient
    {
        public int count = 0;
        public int baseLevel = 0;
        public string tag = "";
        public string name = "";
        public int baseArmorClass = 10;
        public int hp = 1;
        public int hpDice = 10;
        public int hpMod = 0;
        public string gender = "male";
        public List<civUnitNaturalAttack> natural_attacks = new List<civUnitNaturalAttack>();
        public civEquipment equipment = new civEquipment();
    };

    public class civUnit
    {
        public string tag = "";
        public int bpPerTurn = 0;
        public int speed = 0;
        public string name = "";
        public List<civUnitSentient> sentients = new List<civUnitSentient>();
        public int worldgenStrength = 1;
    };

    public class Civilization
    {
        public int techLevel = 0;
        public string tag = "";
        public string speciesTag = "";
        public string ai = "";
        public string nameGenerator = "normal";
        public Dictionary<string, civUnit> units = new Dictionary<string, civUnit>();
        public List<string> evolvesInto = new List<string>();
        public List<string> canBuild = new List<string>();
    };

    class stringTable
    {
        public List<string> strings = new List<string>();

        public string randomEntry(Random rng)
        {
            int position = rng.Next(1, strings.Count) - 1;
            return strings[position];
        }
    }

    class biomeType
    {
        public string name = "";
        public int minRain = 0, maxRain = 100, minTemp = -100, maxTemp = 100;
        public int minMutation = 0, maxMutation = 100, soilPct = 50, sandPct = 50;
        public List<int> occurs = new List<int>();
        public int worldgenTextureIndex = 0;
        public List<(string, int)> plants = new List<(string, int)>();
        public List<string> wildlife = new List<string>();
        public int deciduousTreeChance = 0;
        public int evergreenTreeChance = 0;
        public List<string> nouns = new List<string>();
    };

    enum blockType
    {
        MAX_BLOCK_TYPE = 9,
        NONE = 0,
        WATER = 1,
        PLAINS = 2,
        HILLS = 3,
        MOUNTAINS = 4,
        MARSH = 5,
        PLATEAU = 6,
        HIGHLANDS = 7,
        COASTAL = 8,
        SALT_MARSH = 9,
    }

    public struct lifeEvent
    {
        public readonly int year;
        public readonly string type;
        public lifeEvent(int year, string type)
        {
            this.year = year;
            this.type = type;
        }

    }

    public class History
    {
        public Dictionary<int, List<lifeEvent>> settlerLifeEvent = new Dictionary<int,List<lifeEvent>>();
    }

    public class Civ
    {
        public int techLevel = 0, glyph = 0;
        public bool extinct = false;
        public string speciesTag = "", name = "", leaderName = "", origin = "";
        public byte r = 0, g = 0, b = 0;
        public int startX = 0, startY = 0, cordexFeelings;
        public bool metCordex = false;
        public Dictionary<int, int> relations = new Dictionary<int,int>();
    }

    public class regionInfo
    {
        public int ownerCiv = 0, blightLevel = 0, settlementSize = 0;
        public List<string> improvements = new List<string>();
    }

    public class Unit
    {
        public int ownerCiv = 0, worldX = 0, worldY = 0;
        public string unitType = "";
        public bool dead = false;
    }

    public class civHolder
    {
        public List<Civ> civs = new List<Civ>();
        public List<Unit> units = new List<Unit>();
        public List<regionInfo> regionInfo = new List<regionInfo>();
    }

    public struct RiverStep
        {
            public int x;
            public int y;

            public RiverStep(int x, int y)
            {
                this.x = x;
                this.y = y;
            }
        }

    public class River
    {
        public string name = "River";
        public int startX = 0, startY = 0;
        public List<RiverStep> route = new List<RiverStep>();
    }

    public class Biome
    {
        public string name = "";
        public int type = 0, meanTemperature = 0, meanRainfall = 0, meanAltitude = 0;
        public int meanVariance = 0, warpMutation = 0, evil = 0, savagery = 0;
        public int centerX = 0, centerY = 0;
    }

    public class Block
    {
        public int height = 0, variance = 0, type = 0;
        public int temperature = 0, rainfall = 0, biomeIdx = -1;
    }

    public class Map
    {
        public string name = "Test World";

        public int rngSeed, perlinSeed, remainingSettlers, migrantCounter;
        public int waterDivisor = 4, plainsDivisor = 3, startingSettlers = 10;

        public int waterHeight, plainsHeight, hillsHeight;

        public List<Block> landBlocks = new List<Block>();
        public List<Biome> biomes = new List<Biome>();
        public List<River> rivers = new List<River>();
        public int idx(int x, int y) { return y * Constants.WORLD_WIDTH + x; }
        public civHolder civs = new civHolder();
        public History history = new History();
    }

    #endregion

    public class WorldCreator
    {
        private const float Persistance = 0.5f;
        private const float Lacunarity = 2f;
        private const int Octaves = 5;
        //public GetBiome biomeMap;
        public Map World;

        public WorldCreator(int seed)
        {
            MapGen gen = new MapGen();
            BiomeMap biomes = new BiomeMap();
            RiverBuilder rivers = new RiverBuilder();
            HistoryMaker history = new HistoryMaker();
            World = new Map();
            Random rng = new Random(seed);

            gen.startMap(ref World);
            gen.noiseMap(ref World, seed, Octaves, Persistance, Lacunarity);
            gen.baseTypeAllocation(ref World);
            gen.markCoastlines(ref World);
            gen.createRainfall(ref World);

            biomes.buildBiomes(ref World, ref rng);
            rivers.buildRivers(ref World, ref rng);
            history.buildInitialCivs(ref World, ref rng);
            history.buildInitialHistory(ref World, ref rng);
            /*
            float[,] heightMap = gen.GenerateNoiseMap(Height, Width, scale, seedHeight, Octaves, Persistance, Lacunarity);
            float[,] tempMap = gen.GenerateNoiseMap(Height, Width, scale, seedTemp, Octaves, Persistance, Lacunarity - 1);
            float[,] humidMap = gen.GenerateNoiseMap(Height, Width, scale, seedHumid, Octaves, Persistance, Lacunarity - 1);
            biomeMap = new GetBiome(heightMap, humidMap, tempMap, Width, Height);
            */
        }
    }
}
